2.1. Опишите АТД LinkedList с предложенным набором операций.
Разделите операции на запросы и команды.
Добавьте где необходимо предусловия и постусловия.
Добавьте запросы статуса команд, для работы которых требуются предусловия (учитывайте в частности случаи, когда список пустой).
Ответ:

abstract class LinkedList<T>:
    //конструктор
    //постусловие: создан пустой список
    LinkedList<T> LinkedList();

    //команды:
    //предусловие: список не пустой
    //постусловие: курсор указывает на первое значение в списке
    void head(); //установить курсор на первое значение в списке

    //предусловие: список не пустой
    //постусловие: курсор указывает на последнее значение в списке
    void tail(); // установить курсор на последнее значение в списке

    //предусловие: курсор указывает на какое-либо значение в списке, и это значение не последнее в списке
    //постусловие: курсор указывает на значение, следующее за текущим
    void right(); //сдвинуть курсор на один шаг вправо

    //предусловие: курсор указывает на какое-либо значение в списке
    //постусловие: вставлено значение справа от текущего значения, курсор не изменил положение
    void put_right(T); // вставить следом за текущим значением новое значение

    //предусловие: курсор указывает на какое-либо значение в списке
    //постусловие: вставлено значение слева от текущего значения, курсор не изменил положение
    void put_left(T); // вставить перед текущим значением новое значение

    //предусловие: курсор указывает на какое-либо значение в списке
    //постусловие: удалено значение, на которое указывал курсор.
    //             курсор смещен к правому соседу, если он есть
    //             в противном случае курсор смещен к левому соседу, если он есть
    void remove(); //удалить текущее значение (на которое указывает курсор)

    //постусловие: список пустой
    void clear(); // очистить список

    //дополнительные команды:
    //постусловие: новое значение добавлено в конец списка
    void add_tail(T); //добавить новое значение в хвост списка

    //предусловие: курсор указывает на какое-либо значение в списке
    //постусловие: текущее значение заменено на заданное, курсор не изменил положение
    void replace(T); //заменить текущее значение (на которое указывает курсор) на заданное

    //предусловие: курсор указывает на какое-либо значение в списке, искомое значение существует в списке правее от положения курсора
    //постусловие: курсор указывает на следующее совпадение с искомым значением
    void find(T); // установить курсор в следующее положение с искомым значением (по отношению к текущему положению)

    //постусловие: из списка удалены все совпадения с искомым значением
    void remove_all(T); // удалить в списке все элементы с указанным значением

    //запросы:
    //предусловие: курсор указывает на какое-либо значение в списке
    T get(); // получить текущее значение (на которое указывает курсор)

    int size(); // посчитать количество значений в списке

    //дополнительные запросы:
    bool is_head(); // находится ли курсор в начале списка?
    bool is_tail(); // находится ли курсор в конце списка?
    bool is_value(); // установлен ли курсор на какой-либо значение в списке

    const int PUT_OK = 0 //последняя операция put* выполнена успешно
    const int PUT_FAIL = 1 //последняя операция put* выполнена с ошибкой
    int get_put_status(); //возвращает PUT_*

    const int REMOVE_OK = 0 //последняя операция remove() выполнена успешно
    const int REMOVE_FAIL = 1 //последняя операция remove() выполнена с ошибкой
    int get_remove_status(); //возвращает REMOVE_*

    const int FIND_NOT_FOUND = 0; //операция find() не вызывалась, либо значение не найдено
    const int FIND_OK = 1; //операция find() сработала успешно
    int get_find_status(); //возвращает FIND_*


Комментарии к решению:
0) в АТД я сознательно убрал упоминание "узлов", т.к. на этом уровне мы говорим только о связном списке и значениях
1) для команд head() и tail(): чтобы узнать статус выполнения достаточно запросов is_head() и is_tail() соответственно
2) для команды right() чтобы узнать статус выполнения достаточно запроса is_value()
3) для команды replace() я посчитал, что отдельного статуса выполнения не требуется и достаточно is_value()
4) для команд put_left и put_right сделан отдельный запрос статуса выполнения get_put_status(), т.к. добавление в список значения может выполнится с ошибкой не только по причине того, что курсор ни на что не указывает, но и в связи с ограничениями реализации АТД
5) для команды remove() сделан запрос статуса выполнения get_remove_status()
6) для команды find() сделан запрос статуса выполнения get_find_status()

2.2. Почему операция tail не сводима к другим операциям (если исходить из эффективной реализации)?
Ответ:
Операцию tail можно выразить через операции head и right (size-1 раз) (нужно учесть конечно пред- и пост-условия). Тогда, с точки зрения эффективности, у такой операции tail будет сложность не менее O(N) независимо от реализации (даже если внутри будет непрерывный массив). Поэтому мы делаем отдельную операцию tail, чтобы оставить свободу для оптимизаций

2.3. Операция поиска всех узлов с заданным значением, выдающая список таких узлов, уже не нужна. Почему?
Ответ:
как уже было сказано в лекции, абстракций у нас на уровне АТД всего две: связный список и хранимые в нем значения. Если мы сделаем метод поиска, возвращающий список узлов, то мы создадим лишние (для решаемой задачи) абстракции: Узел и Список узлов, т.е. опустимся на более слабый уровень абстракций ближе к реализации, создавая ненужные ограничения. АТД должен предлагать по возможности минималистичный набор атомарных операций.

