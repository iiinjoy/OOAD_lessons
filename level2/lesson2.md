Задание 4.
----------
Приведите пример иерархии классов (словесное описание), где применяется принцип Открыт-Закрыт, и обоснуйте, почему одни классы (модули) выбраны открытыми, а другие закрытыми.

Решение.
--------
Существует довольно известный стандарт связи в АСУТП - протокол Modbus. Есть по крайней мере две его разновидности по способу реализации физического уровня: Modbus RTU и Modbus TCP/IP. В стандарте Modbus явно отделены структуры:
1. Protocol Data Unit (PDU) - общая для всех транспортных (физических) уровней спецификация протокола Modbus
2. Application Data Unit (ADU) - индивидуальный для транспортного (физического) уровня пакет, который инкапсулирует внутри себя PDU.

В стандарте явно определены некоторые широко используемые функции (команды) протокола: для чтения/записи регистров/битов и другие, с заданными *Кодами* функций. Так же в стандарте есть диапазон кодов, выделенный для определения пользовательских функций, т.е. PDU **открыт для расширения**.

Напротив, ADU является **закрытым для расширения**, т.к. как правило жестко зависит от реализации транспорта, способа адресации и проверки целостности пакетов. При необходимости можно только создать другой вид транспорта, который тоже будет инкапсулировать внутри себя пакет PDU.

Пример иерархии классов:

```
AbstractModbusPDU_Handler <- ModbusReadRegisters_Handler
AbstractModbusPDU_Handler <- ModbusWriteRegisters_Handler
AbstractModbusPDU_Handler <- UserModbusPDU_Handler

AbstractModbusADU_Trasport <- ModbusRTU_Transport
AbstractModbusADU_Trasport <- ModbusTCP_Transport
```

Здесь AbstractModbusPDU_Handler - АТД для реализации обработчиков PDU-пакетов.
Можно взять готовые обработчики для стандартных функций, таких как: ModbusReadRegisters и ModbusWriteRegisters - они будут **закрытыми для расширения**, т.к. реализовывают уже описанные в стандарте функции. UserModbusPDU_Handler - реализация пользовательских функций, которая потенциально **открыта для расширения**. AbstractModbusPDU_Handler - базовый класс, **открытый для расширения**.

ModbusRTU_Transport, ModbusTCP_Transport - **закрытые для расширения** реализации транспорта.
AbstractModbusADU_Trasport - базовый класс, **открытый для расширения**.

Задание 5.
----------
Какие из пяти принципов повторного использования модуля поддерживаются в используемом вами языке программирования (в дополнение к классам как базовой синтаксической единице)?

Решение.
--------
1. Новый модуль может задавать некоторый базовый тип, который потенциально должен допускать параметризацию другими типами (обобщённые типы, типы-генерики).

Параметризововать другим типом невозможно в Python, однако, этот механизм повторного использования поддерживается иным способом:
за счет динамической типизации мы получаем уже обобщённую реализацию некоторого типа или алгоритма.

2. Новый модуль может объединять несколько функций, которые активно обращаются друг к другу.

Поддерживается в Python через определение класса, а также через модули в языке Python, которые могут содержать схожие по смыслу, потенциально обращающиеся друг к другу функции, например, модуль math - набор математических функций.

3. Новый модуль может входить в семейство модулей, ориентированных на решение некоторой общей задачи, которую не удаётся решить с помощью одного модуля.

Поддерживается в Python через языковой механизм импортирования модулей (import module).

4.  Новый модуль может предлагать конкретную реализацию родительского модуля, которая должна выбираться динамически (полиморфно) -- например, реализация обобщённого типа для конкретного типа-параметра.

Возможно реализовать динамический выбор реализации:

1) тип параметра можно явно узнавать динамически через метод type() и сравнивать с известными типами

2) а метод родительского класса (модуля) можно вызвать так: super().method()

5. Новый модуль может интегрировать общее поведение нескольких модулей, которые различаются лишь деталями.

Поддерживается в Python через множественное наследование и композицию.

Задание 6.
----------

Существуют ли ситуации, когда связи между модулями должны делаться публичными?
Какие метрики вы бы предложили для количественной оценки принципов организации модулей?
Если вы разрабатывали программы, в которых было хотя бы 3-5 классов, как бы вы оценили их модульность по этим метрикам?

Решение.
--------

Связи между модулями по возможности должны быть явными (публичными). Неявные связи (зависимости) приводят к трудноконтролируемому проекту.
Но в ситуациях, когда есть модуль, интегрирующий функционал нескольких модулей, например "подсистема", публичной можно оставить только связь использующего этот модуль части программы. Остальные связи модуля можно считать деталями реализации.

Для количественной оценки принципов организации модулей возможно использовать количество связей исходящих из модуля (модули, от которых зависит данный модуль) и количество связей входящих в него (модули, зависящие от этого модуля). Пользоваться этим можно таким образом:
- стараться делать автономные модули (у которых нет исходящих связей)
- если у автономного модуля всего одна входящая стрелка, то возможно он используется всего один раз и разбиение было не выгодно (оверинжиниринг)
- если связи между модулями образуют направленный циклический граф, значит разбиение на модули произведено неверно (т.н. "проблема циклических зависимостей")
- плохим примером будут ситуации, когда связей слишком много, например "все зависят от всех", или когда захватывается очень большой контекст, из которого используется далеко не всё.
